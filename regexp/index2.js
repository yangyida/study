window.onload = function(){

    //test
    //search
    //match
    //replace

    var str = "1971-81-1991";

    var reg = /(\d\d)(\d\d)|\d\d/g;

    console.log(str.replace(reg, function(a, b, c,d,e){

        //console.log(a);
        //console.log(b);
        //console.log(c);
        console.log(d);
        //console.log(e);
        console.log("----------");
    }));
};

/**
 * 转义字符
 * \n 换行
 * \r 回车
 * \t 水平制表tab
 * \f 换页
 * \v 垂直制表
 * \0 空字符
 * \cX (与X对应的控制字符ctrl+X)
 *
 *
 * .  任意字符(除了回车符和换行符之外的所有字符)
 * \s 空格
 * \S 非空格
 * \d 数字
 * \D 非数字
 * \w 字符(字符 数字 下划线_)
 * \W 非字符
 * \b 独立部分(起始 结束 空格)
 * \B 非独立部分
 * \1 重复的第一个子项
 *
 *
 * 或 |
 *
 * 字符类 [] 整体代表一个字符
 *
 * - 如果-写在[]里面的话，就代表范围的意思
 *
 * ^ 如果^写在[]里面的话，就代表排除的意思
 *   正则的最开始位置，代表起始的意思
 *
 * $ 正则的最后位置，就代表结束的意思
 *
 * 匹配子项、分组操作 () :
 *                    如果有嵌套的情况，外面的组的编号会靠前
 *                    如果不希望捕获某些分组，在分组内加上?:   例(?:Byron).(ok)
 *
 * exp1(?=exp2) 匹配后面是exp2的exp1
 * exp1(?!exp2) 匹配后面不是exp2的exp1
 *
 * 量词: +  {1,}
 *      ?  {0,1}
 *      *  {0,}
 *      {4,7} 最少出现4次，最多出现7次  >=4 <=7
 *      {4,}  最少出现4次, >=4
 *      {4}   正好出现4次  ==4
 *      {,4}  最多出现4次  <=4
 *
 * 贪婪模式: 正则表达式默认为贪婪模式，如果需要关闭贪婪模式则在量词后加上?
 *
 *
 *
 * 正则默认: 区分大小写
 *         匹配成功就会结束，不会继续匹配
 *         不进行多行搜索
 *
 * 如果不区分大小写的话，在正则的最后加标识符 i
 * 如果要全部查找的话，在正则后面加g（全局匹配）
 * 多行搜索 m
 */

/**
 * test 正则去匹配字符串，如果匹配成功就返回真，否则返回假
 * regexp.test(str);
 *
 * search 正则去匹配字符串，如果匹配成功则返回匹配成功的位置，否则返回-1
 * str.search(regexp);
 *
 * match 正则去匹配字符串，如果匹配成功，则返回匹配成功的数组，否则返回null
 * str.match(regexp)
 *
 * replace 正则去匹配字符串，匹配成功的字符串去替换成新的字符串(第二个参数为字符串或回调函数)
 * str.replace(regexp, newStr)
 */
